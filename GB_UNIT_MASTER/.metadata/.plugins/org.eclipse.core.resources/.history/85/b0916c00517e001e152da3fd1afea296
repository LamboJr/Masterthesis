/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "xparameters.h"
//#include "decode_trainer_data.h"
#include "decode_Pokemon_structure.h"

typedef enum {
	IdleState,  // State for Phase before both gAmeboys are ready to communicate
	handshakeState,	//State for handshake between GBs. Phase if only one GB is Ready till the sny signal 8FFF is sen by master
	TrainerDataExchangeState,	//first state for exchanging information. general and trainer card information
	TradingRoomMovementState,	// State for Moving around in the trading room
	PokemonDataExchangeState,	//State for exchanging Data about the Team Pokemon after taking Place in the chair

} s_SystemState;

typedef enum{
	IdleState,
	TrainerData,
	EmptyState1,
	SLOT1And2,
	EmptyState2,
	SLOT3And4,
	EmptyState3,
	SLOT5And6,
} s_DecodeState;


u32 trainerdatabuffer[1000];

u32 MasterMask = 0xFFFF0000;
u32 SlaveMask = 0x0000FFFF;

int main()
{
	u16 PokemonSlot1[50];
	u16 PokemonSlot2[50];
	u16 PokemonSlot3[50];
	u16 PokemonSlot4[50];
	u16 PokemonSlot5[50];
	u16 PokemonSlot6[50];

	u32 *address = NULL;  //address pointer to read/write from/to BRAM controller -> ringbuffer

	u32 MasterDataframeCount = 0; //variable for counting the number of relevant  complete 9er frames !!!
	u32 SlaveDataframeCount = 0; //variable for counting the number of relevant  complete 9er frames !!!

	u32 frameCount = 0;		//count variable for formating the monitoring output and also used for interpreting data
	u32 data;			//variable for storing red in data

	//u32 buffer_index = 0;
	u32 MasterBufferIndex = 0;			//Index variable for indexing the Storage buffers for the Master data frames
	u32 SlaveBufferIndex = 0;			//Index variable for indexing the Storage buffers for the Slave data frames



	//u8 record_data = 0;
	u8 RecordMasterData = 0;	// bool variable. Set to 1 if 8888 is received from the Master so the next 7 data frames are relevant game data
	u8 RecordSlaveData = 0;		// Same for Slave data

	u32 MasterTrainerData[100];	// Storage buffer for Trainer pass info send from master
	u32 SlaveTrainerData[100]; // Storage buffer for Trainer pass info send from Slave

	u32 MasterPokemonData[1000];	// Storage buffer for Pokemon Data structures
	u32 SlavePokemonData[1000];		//Storage buffer for Pokemon Data structures


	//struct TrainerCard Trainer_Card;


	s_SystemState s_NextState = IdleState;	//FSM state vaiable

	s_DecodeState s_NextMasterDecodeState = TrainerData;
	s_DecodeState s_NextSlaveDecodeState = TrainerData;

    address = (u32 *) XPAR_AXI_BRAM_CTRL_0_S_AXI_BASEADDR;  // address points to BASE ADDR of AXI BRAM controller

    u32 i = 0;

	//u32 count = 0;
    init_platform();

    print("Start Monitoring \n");



    while(1){
    	if (*(address+1) == 0){ // checks the empty flag of the ringbuffer Hardware to indicate if there is new data to read from HW

    		data = *(address);
    		//reads from the ringbuffer if its not empty
			switch(s_NextState){

			case IdleState:{
				if(data == 0xB9A0B9A0){
					s_NextState = handshakeState;
					frameCount = 0;
					xil_printf("\nEntering Handshake State\n");
				}
			}break;

			case handshakeState:{
				if(data == 0x8FFFB9A0){frameCount = 8;
				s_NextState = TrainerDataExchangeState;
				xil_printf("\nEntering TradeInformationExchange State\n");
				}
			}break;

			case TrainerDataExchangeState: {
				if (frameCount == 0){}//checksum
				else if (frameCount == 1){

					if ( (data & MasterMask) == 0x88880000){
						RecordMasterData = 1;
					}
					else{RecordMasterData = 0;}
					if ( (data & SlaveMask) == 0x00008888){
						RecordSlaveData = 1;
					}
					else{RecordSlaveData= 0;}
				}

				else {
					if (RecordMasterData == 1){
						MasterTrainerData[MasterBufferIndex] = data & MasterMask;
						MasterBufferIndex++;
					}
					if (RecordSlaveData == 1){
						SlaveTrainerData[SlaveBufferIndex] = data & SlaveMask;
						SlaveBufferIndex++;
					}
				}


				if(data == 0xCAFECAFE){
					s_NextState = TradingRoomMovementState;
					//print_trainer_data(MasterTrainerData, Trainer_Card);




				}
			}break;


			case TradingRoomMovementState:{
				if(data == 0x8FFFB9A0){frameCount = 8;
					s_NextState = PokemonDataExchangeState;
					xil_printf("\nEntering Pokemon Data Exchange phase\n");
					MasterBufferIndex = 0;
					SlaveBufferIndex = 0;}
			}break;


			case PokemonDataExchangeState:{
				if (frameCount == 0){}//checksum
				else if (frameCount == 1){

					if ( (data & MasterMask) == 0x88880000){
						RecordMasterData = 1;
						MasterDataframeCount++;
					}
					else{RecordMasterData = 0;}
					if ( (data & SlaveMask) == 0x00008888){
						RecordSlaveData = 1;
						SlaveDataframeCount++;
					}
					else{RecordSlaveData= 0;}

					switch(s_NextMasterDecodeState){
						case IdleState: {
							if (RecordMasterData == 1){
								s_NextMasterDecodeState = TrainerData;
							}
						}break;
						case TrainerData: {
							if (RecordMasterData == 0){
								s_NextMasterDecodeState = EmptyState1;
							}

						}break;
						case EmptyState1: {
							if (RecordMasterData == 1){
								s_NextMasterDecodeState = SLOT1And2;
							}
						}break;
						case SLOT1And2: {}break;
						case EmptyState2: {
							if (RecordMasterData == 1){
								s_NextMasterDecodeState = SLOT3And4;
							}
						}break;
						case SLOT3And4: {}break;
						case EmptyState3: {
							if (RecordMasterData == 1){
								s_NextMasterDecodeState = SLOT5And6;
							}
						}break;
						case SLOT5And6: {}break;
					}

				}
				else {




					if (RecordMasterData == 1){
						//Adds the frame number to the entry in the Pokemon buffer
						//MasterPokemonData[MasterBufferIndex] = (MasterDataframeCount << 16);
						MasterPokemonData[MasterBufferIndex] = ((data & MasterMask) >> 16);
						if (frameCount == 2){
							decode_Pokemon_data(MasterPokemonData[MasterBufferIndex], MasterDataframeCount);
						}
						MasterBufferIndex++;
					}
					else{

					}
					if (RecordSlaveData == 1){


						SlavePokemonData[SlaveBufferIndex] = data & SlaveMask;
						SlaveBufferIndex++;
					}



				}

			}break;



			default:break;
			}




			xil_printf("0x%08x    ",data);
			if ((frameCount % 8 == 0) && (frameCount != 0)){xil_printf("\n");frameCount = 0;}
			else{frameCount++;}

    	}
    }
    cleanup_platform();
    return 0;
}
//xil_printf("\n Master Trainer buffer \n");
/*for ( i = 0; i <= buffer_index; i++) {
	xil_printf("0x%08x    ",trainerdatabuffer[i]);
	if ((i % 9== 0 ) && (i != 0)){xil_printf("\n");}
}*/
/*for (i = 0; i <= MasterBufferIndex; i++){
	xil_printf("0x%08x    ",MasterTrainerData[i]);
	if (((i+1) % 9== 0 )){xil_printf("\n");}
}
xil_printf("\n Slave Trainer buffer \n");
for (i = 0; i <= SlaveBufferIndex; i++){
	xil_printf("0x%08x    ",SlaveTrainerData[i]);
	if (((i+1) % 9== 0 )){xil_printf("\n");}
}
xil_printf("\nTradindRoomMovement\n");
*/
